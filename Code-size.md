#### Code size factor

There isn’t an explicit size “cap” built into Janino itself; rather, the practical limits come from two main factors:

1. **Java String and Memory Limits:**  
   The dynamic code you supply to Janino is held in a Java String. In Java, a String can theoretically hold up to about 2³¹–1 characters (limited by the maximum array size), but in practice the size is limited by the available memory. So, while we can pass a very large string, the actual limit will depend on our system’s memory.

2. **JVM Bytecode Method Size Limit:**  
   The JVM imposes a hard limit of 64 KB (65,535 bytes) on the size of the bytecode for a single method. If your dynamic code compiles into one method, the resulting bytecode must not exceed this limit. If it does, Janino (like javac) will throw an exception (for example, an InternalCompilerException with a message such as “Code grows beyond 64 KB”).  
   

**In practice:**  
Janino is designed for dynamic compilation of small to moderately sized code fragments—such as expressions, scripts, or small class bodies. If we try to pass an extremely large code body (for example, several thousand lines that might generate a single enormous method), we could run into the 64 KB bytecode limit for that method or suffer from performance issues.

**Summary:**  
- The size of the code string is essentially limited by available memory (and the theoretical maximum size of a Java String).  
- However, any single method generated by the compiler is capped at 64 KB of bytecode.  
- Janino works best for relatively small, dynamic code fragments; if e need to compile a very large code base dynamically, we may need to split the code into multiple classes or consider using a standard compiler like javac.

This means that while we can pass a large amount of code in a string, we should design our dynamic code so that it’s modular (i.e., spread across several methods or classes) rather than a single giant method, to avoid hitting the JVM’s bytecode size limit.
